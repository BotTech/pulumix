import { readdirSync, statSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import * as semver from 'semver'

const schemasDir = join(import.meta.dirname, '..', 'schemas', 'plan')

// Find all schema directories and parse versions
const versions = readdirSync(schemasDir)
  .filter((name) => {
    const fullPath = join(schemasDir, name)
    return statSync(fullPath).isDirectory()
  })
  .map((name) => {
    const normalized = name.startsWith('v') ? name.slice(1) : name
    return {
      original: name,
      normalized,
      parsed: semver.parse(normalized)!,
    }
  })
  .filter((v) => v.parsed !== null)
  .sort((a, b) => semver.compare(a.normalized, b.normalized))

if (versions.length === 0) {
  console.error('No valid versions found')
  process.exit(1)
}

console.log(`Found ${versions.length} schema versions:`)
versions.forEach((v) => console.log(`  - ${v.original}`))

// Get min and max versions
const minVersion = versions[0]
const maxVersion = versions[versions.length - 1]

console.log(`\nMin version: ${minVersion.original}`)
console.log(`Max version: ${maxVersion.original}`)

// Build version map: major -> minor -> patch -> schema version
interface VersionNode {
  [key: number]: VersionNode | string
}

const versionMap: VersionNode = {}

for (const version of versions) {
  const { major, minor, patch } = version.parsed
  
  if (!versionMap[major]) {
    versionMap[major] = {}
  }
  const majorMap = versionMap[major] as VersionNode
  
  if (!majorMap[minor]) {
    majorMap[minor] = {}
  }
  const minorMap = majorMap[minor] as VersionNode
  
  minorMap[patch] = version.original
}

console.log('\nVersion map structure:')
console.log(JSON.stringify(versionMap, null, 2))

// Build the entire file content as a string
let fileContent = `/**
 * Auto-generated version type mappings.
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-version-types.ts
 *
 * @module plan.generated
 */

`

// Add imports for each version
fileContent += versions
  .map(
    (v) =>
      `import type { DeploymentPlan as DeploymentPlan_${v.original.replace(/\./g, '_')} } from '../schemas/plan/${v.original}/plan.js'`
  )
  .join('\n')
fileContent += '\n\n// Re-export all plan types\n'
fileContent += versions
  .map(
    (v) =>
      `export type { DeploymentPlan_${v.original.replace(/\./g, '_')} }`
  )
  .join('\n')
fileContent += '\n\n// Export the latest version as DeploymentPlan\n'
fileContent += `export type { DeploymentPlan_${maxVersion.original.replace(/\./g, '_')} as DeploymentPlan }`
fileContent += '\n'

// Generate the major version map type
function generateMajorMapType(): string {
  const majorEntries: string[] = []
  const maxMajor = maxVersion.parsed.major
  let lastKnownMinorMap: string | null = null
  let maxMinorMapType: string | null = null
  
  for (let major = 0; major <= maxMajor; major++) {
    if (major < minVersion.parsed.major) {
      // Before minimum version, use last known or never
      if (lastKnownMinorMap) {
        majorEntries.push(`  ${major}: ${lastKnownMinorMap}`)
      } else {
        majorEntries.push(`  ${major}: never`)
      }
    } else if (versionMap[major]) {
      const minorMap = `MinorVersionMap_${major}`
      majorEntries.push(`  ${major}: ${minorMap}`)
      lastKnownMinorMap = minorMap
      maxMinorMapType = minorMap
    } else {
      // Use the max known major version
      if (lastKnownMinorMap) {
        majorEntries.push(`  ${major}: ${lastKnownMinorMap}`)
      } else {
        majorEntries.push(`  ${major}: never`)
      }
    }
  }
  
  // Add MAX entry that points to the maximum minor map in this major map
  if (maxMinorMapType) {
    majorEntries.push(`  MAX: ${maxMinorMapType}`)
  } else if (lastKnownMinorMap) {
    majorEntries.push(`  MAX: ${lastKnownMinorMap}`)
  } else {
    majorEntries.push(`  MAX: never`)
  }
  
  return `type MajorVersionMap = {\n${majorEntries.join('\n')}\n}`
}

// Generate minor version map types for each major
function generateMinorMapTypes(): string {
  const types: string[] = []
  
  // Get all majors we need to generate
  const majors = Object.keys(versionMap).map(Number).sort((a, b) => a - b)
  
  for (const major of majors) {
    const majorMap = versionMap[major] as VersionNode
    const minors = Object.keys(majorMap).map(Number).sort((a, b) => a - b)
    const maxMinor = Math.max(...minors)
    
    const minorEntries: string[] = []
    let lastKnownPatchMap: string | null = null
    let maxPatchMapType: string | null = null
    
    for (let minor = 0; minor <= maxMinor; minor++) {
      // Special case for minimum major version
      if (major === minVersion.parsed.major && minor < minVersion.parsed.minor) {
        // Before minimum version, use last known or never
        if (lastKnownPatchMap) {
          minorEntries.push(`  ${minor}: ${lastKnownPatchMap}`)
        } else {
          minorEntries.push(`  ${minor}: never`)
        }
      } else if (majorMap[minor]) {
        const patchMap = `PatchVersionMap_${major}_${minor}`
        minorEntries.push(`  ${minor}: ${patchMap}`)
        lastKnownPatchMap = patchMap
        maxPatchMapType = patchMap
      } else {
        // Find the max known minor less than or equal to current
        const knownMinor = minors.filter((m) => m <= minor).sort((a, b) => b - a)[0]
        if (knownMinor !== undefined) {
          const patchMap = `PatchVersionMap_${major}_${knownMinor}`
          minorEntries.push(`  ${minor}: ${patchMap}`)
          if (!maxPatchMapType) maxPatchMapType = patchMap
        } else if (lastKnownPatchMap) {
          // No known minor, fallback to last known
          minorEntries.push(`  ${minor}: ${lastKnownPatchMap}`)
        } else {
          minorEntries.push(`  ${minor}: never`)
        }
      }
    }
    
    // Add MAX entry that points to the maximum patch map in this minor map
    if (maxPatchMapType) {
      minorEntries.push(`  MAX: ${maxPatchMapType}`)
    } else if (lastKnownPatchMap) {
      minorEntries.push(`  MAX: ${lastKnownPatchMap}`)
    } else {
      minorEntries.push(`  MAX: never`)
    }
    
    types.push(`type MinorVersionMap_${major} = {\n${minorEntries.join('\n')}\n}`)
  }
  
  return types.join('\n\n')
}

// Generate patch version map types for each major.minor
function generatePatchMapTypes(): string {
  const types: string[] = []
  let lastKnownVersion: string | null = null
  
  for (const version of versions) {
    const { major, minor, patch } = version.parsed
    const minorMap = (versionMap[major] as VersionNode)[minor] as VersionNode
    const patches = Object.keys(minorMap).map(Number).sort((a, b) => a - b)
    const maxPatch = Math.max(...patches)
    
    const patchEntries: string[] = []
    let maxVersionType: string | null = null
    
    for (let p = 0; p <= maxPatch; p++) {
      // Special case for minimum version
      if (
        major === minVersion.parsed.major &&
        minor === minVersion.parsed.minor &&
        p < minVersion.parsed.patch
      ) {
        // Before minimum version, use never only if no previous version exists
        if (lastKnownVersion) {
          patchEntries.push(`  ${p}: DeploymentPlan_${lastKnownVersion.replace(/\./g, '_')}`)
        } else {
          patchEntries.push(`  ${p}: never`)
        }
      } else if (minorMap[p]) {
        const versionStr = (minorMap[p] as string).replace(/\./g, '_')
        patchEntries.push(`  ${p}: DeploymentPlan_${versionStr}`)
        lastKnownVersion = minorMap[p] as string
        maxVersionType = versionStr
      } else {
        // Find the max known patch less than or equal to current
        const knownPatch = patches.filter((pt) => pt <= p).sort((a, b) => b - a)[0]
        if (knownPatch !== undefined) {
          const versionStr = (minorMap[knownPatch] as string).replace(/\./g, '_')
          patchEntries.push(`  ${p}: DeploymentPlan_${versionStr}`)
          if (!maxVersionType) maxVersionType = versionStr
        } else if (lastKnownVersion) {
          // No known patch in this minor, fallback to last known version
          patchEntries.push(`  ${p}: DeploymentPlan_${lastKnownVersion.replace(/\./g, '_')}`)
        } else {
          patchEntries.push(`  ${p}: never`)
        }
      }
    }
    
    // Add MAX entry that points to the maximum version in this patch map
    if (maxVersionType) {
      patchEntries.push(`  MAX: DeploymentPlan_${maxVersionType}`)
    } else if (lastKnownVersion) {
      patchEntries.push(`  MAX: DeploymentPlan_${lastKnownVersion.replace(/\./g, '_')}`)
    } else {
      patchEntries.push(`  MAX: never`)
    }
    
    // Only generate once per major.minor
    const key = `${major}_${minor}`
    if (!types.some((t) => t.includes(`PatchVersionMap_${key}`))) {
      types.push(`type PatchVersionMap_${major}_${minor} = {\n${patchEntries.join('\n')}\n}`)
    }
  }
  
  return types.join('\n\n')
}

// Generate the main lookup type
function generateLookupType(): string {
  return `/**
 * Helper type to get the max (last) value from a map when accessing by index.
 * If the key exists, returns the value at that key.
 * Otherwise, returns the value at the 'MAX' key (the max version).
 */
type GetFromMapOrMax<Map extends { MAX: unknown }, Key> = 
  Key extends keyof Map 
    ? Map[Key]
    : Map['MAX']

/**
 * Internal type to look up plan type from version components.
 */
type LookupPlanType<Major extends number, Minor extends number, Patch extends number> =
  Major extends keyof MajorVersionMap
    ? MajorVersionMap[Major] extends infer MinorMap
      ? [MinorMap] extends [never]
        ? never
        : MinorMap extends { MAX: unknown }
          ? Minor extends keyof MinorMap
            ? MinorMap[Minor] extends infer PatchMap
              ? [PatchMap] extends [never]
                ? never
                : PatchMap extends { MAX: unknown }
                  ? GetFromMapOrMax<PatchMap, Patch>
                  : never
              : never
            : GetFromMapOrMax<MinorMap, Minor> extends infer PatchMap
              ? [PatchMap] extends [never]
                ? never
                : PatchMap extends { MAX: unknown }
                  ? GetFromMapOrMax<PatchMap, Patch>
                  : never
              : never
          : never
      : never
    : DeploymentPlan_${maxVersion.original.replace(/\./g, '_')}

/**
 * Extract version components and look up the corresponding plan type.
 * Returns 'never' for versions before ${minVersion.original}.
 * Returns the maximum matching version type for versions beyond our known schemas.
 */
export type DeploymentPlanForVersion<V extends string> =
  V extends \`v\${infer Major extends number}.\${infer Minor extends number}.\${infer Patch extends number}\`
    ? LookupPlanType<Major, Minor, Patch>
    : V extends \`v\${infer Major extends number}.\${infer Minor extends number}.\${infer Patch extends number}-\${string}\`
    ? LookupPlanType<Major, Minor, Patch>
    : V extends \`v\${infer Major extends number}.\${infer Minor extends number}.\${infer Patch extends number}+\${string}\`
    ? LookupPlanType<Major, Minor, Patch>
    : V extends \`\${infer Major extends number}.\${infer Minor extends number}.\${infer Patch extends number}\`
    ? LookupPlanType<Major, Minor, Patch>
    : V extends \`\${infer Major extends number}.\${infer Minor extends number}.\${infer Patch extends number}-\${string}\`
    ? LookupPlanType<Major, Minor, Patch>
    : V extends \`\${infer Major extends number}.\${infer Minor extends number}.\${infer Patch extends number}+\${string}\`
    ? LookupPlanType<Major, Minor, Patch>
    : never`
}

// Add all the generated types
fileContent += '\n' + generatePatchMapTypes()
fileContent += '\n\n' + generateMinorMapTypes()
fileContent += '\n\n' + generateMajorMapType()
fileContent += '\n\n' + generateLookupType()

// Export the available versions type
const versionLiterals = versions.map((v) => `'${v.original}'`).join(' | ')
fileContent += `\n\n/**
 * Union type of all available schema versions.
 */
export type Version = ${versionLiterals}\n`

// Write the file
const outputPath = join(import.meta.dirname, '..', 'src', 'plan.generated.d.ts')
writeFileSync(outputPath, fileContent, 'utf-8')

console.log('\n✓ Version type mappings generated successfully')
console.log(`  Output: src/plan.generated.d.ts`)
